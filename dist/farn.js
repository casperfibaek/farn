"use strict";function intersect(a,b){if(a[0][0]===b[0][0]&&a[0][1]===b[0][1]&&a[1][0]===b[1][0]&&a[1][1]===b[1][1])return[a[0][0],a[0][1]];if(a[0][0]===b[0][0]&&a[0][1]===b[0][1]||a[0][0]===b[1][0]&&a[0][1]===b[1][1])return[a[0][0],a[0][1]];if(a[1][0]===b[0][0]&&a[1][1]===b[0][1]||a[1][0]===b[1][0]&&a[1][1]===b[1][1])return[a[1][0],a[1][1]];const c=a[1][0]-a[0][0],d=a[1][1]-a[0][1],e=b[1][0]-b[0][0],f=b[1][1]-b[0][1],g=f*c-e*d;if(0===g)return!1;const h=a[0][0]-b[0][0],i=a[0][1]-b[0][1],j=(e*i-f*h)/g,k=(c*i-d*h)/g;if(0<=j&&1>=j&&0<=k&&1>=k){const b=[a[0][0]+j*c,a[0][1]+j*d];return b}return!1}function distance(a,b){var c=Math.pow;return Math.sqrt(c(b[0]-a[0],2)+c(b[1]-a[1],2))}function angle(a,b){var c=Math.PI,d=Math.atan2;if(a[0]===b[0]&&a[1]===b[1])return 0;let e=d(a[0]-b[0],b[1]-a[1]);return 0>e&&(e+=2*c),e}function isPointOnLine(a,b,c=Number.EPSILON){const d=b[1][1]-b[0][1],e=b[1][0]-b[0][0];if(0===e||0==d){if(a[0]===b[0][0]){let c,d;if(b[0][1]>=b[1][1]?(c=b[1][1],d=b[0][1]):(c=b[0][1],d=b[1][1]),a[1]>=c&&a[1]<=d)return!0}else if(a[1]===b[0][1]){let c,d;if(b[0][0]>=b[1][0]?(c=b[1][0],d=b[0][0]):(c=b[0][0],d=b[1][0]),a[0]>=c&&a[0]<=d)return!0}return!1}const f=d/e,g=b[0][1]-f*b[0][0],h=Math.abs(a[1]-(f*a[0]+g));return!0==h<=c}function pointFromTwoPoints(a,b,c=0){var d=Math.pow;if(0===c)return a;const e=b[0]-a[0],f=b[1]-a[1],g=d(e,2)+d(f,2),h=Math.sqrt(g);return[a[0]+e/h*c,a[1]+f/h*c]}function pointFromRatio(a,b,c=.5){if(0===c)return a;if(1===c)return b;const d=b[0]-a[0],e=b[1]-a[1];return[a[0]+d*c,a[1]+e*c]}function pointFromAngle(b,c,a=0){return[Math.cos(c)*a+b[0],Math.sin(c)*a+b[1]]}function pointFromOriginRotation(b,c,d){const a=Math.cos(d),e=Math.sin(d),f=a*(c[0]-b[0])+e*(c[1]-b[1])+b[0],g=a*(c[1]-c[1])-e*(c[0]-c[0])+b[1];return[f,g]}function nearestPointOnLine(a,c){var d=Math.pow;const e=c[1][0]-c[0][0],f=c[1][1]-c[0][1],g=a[0]-c[0][0],h=a[1]-c[0][1],i=e*g+f*h;if(0>=i)return c[0];const j=d(e,2)+d(f,2);if(j<=i)return c[1];const k=i/j,b=[e*k,f*k];return[c[0][0]+b[0],c[0][1]+b[1]]}function area(a){let b=0;for(let c=0;c<a.length-1;c+=1){const d=c==a.length-1?0:c+1;b+=a[c][0]*a[d][1]-a[d][0]*a[c][1]}return Math.abs(b)/2}function bbox(a){const c=[1/0,1/0,-Infinity,-Infinity];for(let b=0;b<a.length-1;b+=1)c[0]>a[b][0]&&(c[0]=a[b][0]),c[1]>a[b][1]&&(c[1]=a[b][1]),c[2]<a[b][0]&&(c[2]=a[b][0]),c[3]<a[b][1]&&(c[3]=a[b][1]);return c}function lineStringLength(a){let b=0;for(let c=0;c<a.length-1;c+=1)b+=distance(a[c],a[c+1]);return b}function pointAlongLineString(b,c=0){if(0===c)return b[0];let d=0;for(let a=0;a<b.length-1;a+=1){if(d+=distance(b[a],b[a+1]),d===c)return b[a+1];if(d>c)return pointFromTwoPoints(b[a+1],b[a],d-c)}return pointFromTwoPoints(b[b.length-2],b[b.length-1])}function perpendicularPointsSegment(a,c,e,d=!0){const b=pointFromTwoPoints(a[0],a[1],c),f=pointFromAngle(b,e,angle(a[0],a[1])-.5*Math.PI);if(d)return f;const g=[f[0]+-1*(b[0]-f[0]),f[1]+-1*(b[1]-f[1])];return g}function shiftLineLeft(a,b){const c=pointFromAngle(a[0],b,angle(a[0],a[1])-.5*Math.PI),d=[a[0][0]-c[0],a[0][1]-c[1]],e=[a[1][0]+d[0],a[1][1]+d[1]];return[c,e]}function shiftLineRight(a,b){const c=pointFromAngle(a[0],b,angle(a[0],a[1])+.5*Math.PI),d=[a[0][0]-c[0],a[0][1]-c[1]],e=[a[1][0]+d[0],a[1][1]+d[1]];return[c,e]}function isPointInsidePolygon(a,b){const c=a[0],d=a[1];for(let e=0;e<b.length;e+=1){const a=0<e?e-1:b.length-1,f=b[e][0],g=b[e][1],h=b[a][0],i=b[a][1];if(c===b[e][0]&&d===b[e][1])return!0;if(g>d!=i>d&&c<(h-f)*(d-g)/(i-g+f))return!0}return!1}function createCircle(a,b,c=24){var d=Math.sin,e=Math.cos,f=Math.PI;const g=Array(c+1);for(let h=0;h<c;h+=1){const i=h/(c/2)*f,j=a[0]-b*e(i),k=a[1]-b*d(i);g[h]=[j,k]}return g[g.length-1]=a,g}var base=Object.freeze({intersect:intersect,distance:distance,angle:angle,isPointOnLine:isPointOnLine,pointFromTwoPoints:pointFromTwoPoints,pointFromRatio:pointFromRatio,pointFromAngle:pointFromAngle,pointFromOriginRotation:pointFromOriginRotation,nearestPointOnLine:nearestPointOnLine,area:area,bbox:bbox,lineStringLength:lineStringLength,pointAlongLineString:pointAlongLineString,perpendicularPointsSegment:perpendicularPointsSegment,shiftLineLeft:shiftLineLeft,shiftLineRight:shiftLineRight,isPointInsidePolygon:isPointInsidePolygon,createCircle:createCircle});const farn=Object.assign({},base);window&&(window.farn=farn),module.exports=farn;
